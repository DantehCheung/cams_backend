package com.fyp.crms_backend.task

import com.fyp.crms_backend.algorithm.Snowflake
import com.fyp.crms_backend.utils.Logger
import org.springframework.dao.DataAccessException
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.mail.SimpleMailMessage
import org.springframework.mail.javamail.JavaMailSender
import org.springframework.scheduling.annotation.Scheduled
import org.springframework.stereotype.Component
import org.springframework.transaction.annotation.Transactional
import java.time.LocalDate

@Component
class ScheduledTasks(
    jdbcTemplate: JdbcTemplate,
    private val mailSender: JavaMailSender
):Logger(jdbcTemplate, Snowflake(1, 2)) {


    data class OverdueRecord(
        val cna: String,
        val fullName: String,
        val email: String,
        val deviceIDs: List<Int>,
        val deviceNames: List<String>,
        val latestLease: LocalDate
    )

    @Scheduled(cron = "0 0 9 * * ?", zone = "Asia/Hong_Kong")
    @Transactional
    fun checkOverdueDevices() {
        val overdueRecords = jdbcTemplate.query(
            """
SELECT 
  u.CNA,
  CONCAT(u.firstName, ' ', u.lastName) AS fullName,
  GROUP_CONCAT(d.deviceID SEPARATOR ',') AS deviceIDs,
  GROUP_CONCAT(d.deviceName SEPARATOR '|') AS deviceNames,
  MAX(br.leasePeriod) AS latestLease,
  CONCAT(u.CNA, '@', u.emailDomain) AS email
FROM DeviceBorrowRecord br
JOIN User u ON br.borrowUserCNA = u.CNA
JOIN Device d ON br.deviceID = d.deviceID
LEFT JOIN DeviceReturnRecord rr ON br.borrowRecordID = rr.borrowRecordID
WHERE u.accessLevel = 1000
  AND d.state = 'L'
  AND rr.returnDate IS NULL
  AND br.leasePeriod < CURDATE()
GROUP BY u.CNA;"""
        ) { rs, _ ->
            OverdueRecord(
                rs.getString("CNA"),
                rs.getString("fullName"),
                rs.getString("email"),
                rs.getString("deviceIDs").split(",").map { it.toInt() }, // 转换设备ID
                rs.getString("deviceNames").split("|"),
                rs.getDate("latestLease").toLocalDate()
            )
        }

        overdueRecords.forEach { record ->
            sendReminderEmail(record)
            updateDeviceState(record.deviceIDs) // 新增状态更新
        }
    }

    private fun updateDeviceState(deviceIDs: List<Int>) {
        if (deviceIDs.isNotEmpty()) {
            jdbcTemplate.update(
                "UPDATE Device SET state = 'E' WHERE deviceID IN (${deviceIDs.joinToString(",")}) AND state = 'L'"
            )
        }
    }

    private fun sendReminderEmail(record: OverdueRecord) {
        try {
            val deviceList = record.deviceNames.mapIndexed { index, name ->
                "${index + 1}. $name"
            }.joinToString("\n")

            val emailText = """
Dear ${record.fullName},

This is a reminder that you have not yet returned the following devices, which are now overdue:
${deviceList}

Please return these items at your earliest convenience to avoid any late fees or penalties. You can return the devices to the designated drop-off location or contact us for further assistance.

Important: This is an automated message generated by the CAMS system. Please do not reply to this email as it is not monitored.

Thank you for your prompt attention to this matter!

Best regards,
CAMS System
        """.trimIndent()

            SimpleMailMessage().apply {
                setTo(record.email)
                subject = "Reminder: Overdue Device Return"
                text = emailText
            }.also {
                mailSender.send(it)
                addLog("Email sent to ${record.email} regarding overdue devices: ${record.deviceIDs.joinToString(",")}")
            }
        } catch (ex: Exception) {
            println("Failed to send email to ${record.email}:\n$ex")
        }
    }

    @Scheduled(cron = "0 0 0 * * ?", zone = "Asia/Hong_Kong")
    @Transactional
    fun updateReservationStatus() {
        jdbcTemplate.update("""
            UPDATE Device d
            JOIN DeviceBorrowRecord br ON d.deviceID = br.deviceID
            SET d.state = 'R'
            WHERE d.state = 'A'
              AND br.borrowDate = CURDATE()
              AND NOT EXISTS (
                SELECT 1 FROM DeviceReturnRecord 
                WHERE borrowRecordID = br.borrowRecordID
              )
        """)
        addLog("Updated status for devices")
    }

    //@Scheduled(cron = "20 31 1 * * *", zone = "Asia/Hong_Kong")
//    fun sendDailyEmail() {
//        println("testMail")
//        try {
//            val message = SimpleMailMessage().apply {
//                setTo("230243196@stu.vtc.edu.hk")
//                setSubject("test")
//                text = "test email"
//            }
//            mailSender.send(message)
//            println("郵件已發送於 ${java.time.LocalDateTime.now()}")
//        } catch (e: Exception) {
//            println("郵件發送失敗: ${e.message}")
//            e.printStackTrace()
//        }
//    }


}